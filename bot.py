# bot_safejob_final.py
# -*- coding: utf-8 -*-
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    InputMediaPhoto,
    InputMediaVideo,
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters,
)

# ======================
# CONFIGURA√á√ïES
# ======================
TOKEN = "8200201915:AAHxipR8nov2PSAJ3oJLIZDqplOnxhHYRUc"            # <-- coloque seu token aqui
GROUP_ID = int("-5014344988")      # <-- grupo destino (inteiro)

LANGUAGES = {
    "en": "üá¨üáß English",
    "pt": "üáßüá∑ Portugu√™s",
    "es": "üá™üá∏ Espa√±ol",
    "ru": "üá∑üá∫ –†—É—Å—Å–∫–∏–π",
}

SECURITY_MSG = {
    "en": "üîí Welcome to SafeJob!\nEvery job opportunity shared here is carefully reviewed by our team.\nPlease fill in your information carefully so our team can find the best position for you.",
    "pt": "üîí Bem-vindo ao SafeJob!\nTodas as vagas publicadas aqui s√£o cuidadosamente analisadas pela nossa equipe.\nPor favor, preencha suas informa√ß√µes com aten√ß√£o para que possamos encontrar a melhor vaga para voc√™.",
    "es": "üîí ¬°Bienvenido a SafeJob!\nTodas las vacantes aqu√≠ son revisadas cuidadosamente por nuestro equipo.\nPor favor, completa tu informaci√≥n con atenci√≥n para que podamos encontrar el mejor puesto para ti.",
    "ru": "üîí –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ SafeJob!\n–í—Å–µ –≤–∞–∫–∞–Ω—Å–∏–∏ —Ç—â–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –Ω–∞—à–µ–π –∫–æ–º–∞–Ω–¥–æ–π.\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω—è–π—Ç–µ –¥–∞–Ω–Ω—ã–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –ø–æ–¥–æ–±—Ä–∞—Ç—å –ª—É—á—à—É—é –≤–∞–∫–∞–Ω—Å–∏—é –¥–ª—è –≤–∞—Å.",
}

FINAL_MSG = {
    "en": "‚úÖ Thank you! Our team will review your information and contact you soon. üîé",
    "pt": "‚úÖ Obrigado! Nossa equipe ir√° analisar suas informa√ß√µes e entrar√° em contato em breve. üîé",
    "es": "‚úÖ ¬°Gracias! Nuestro equipo revisar√° tu informaci√≥n y se pondr√° en contacto pronto. üîé",
    "ru": "‚úÖ –°–ø–∞—Å–∏–±–æ! –ù–∞—à–∞ –∫–æ–º–∞–Ω–¥–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç –≤–∞—à—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏ —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è. üîé",
}

QUESTIONS = {
    "en": [
        "üë§ What's your full name?",
        "üéÇ How old are you?",
        "üè≥Ô∏è What's your nationality?",
        "üíº Tell us about your professional experiences.",
        "üåê What languages do you speak?",
        "üìç Where are you currently located?",
        "‚ö†Ô∏è Do you have any fines to pay? (Yes/No)",
        "üõÇ Do you have a valid work visa? (Yes/No)",
        "üöö Are you available to relocate? (Yes/No)",
        "üì∏ Are you a model and want to provide photos? (Yes/No) ‚Äì optional",
        "üé• Send a presentation video (up to 1 minute)",
        "üì± What is your Telegram username or number for contact?",
        "üìù Any additional notes?",
    ],
    "pt": [
        "üë§ Qual √© o seu nome completo?",
        "üéÇ Quantos anos voc√™ tem?",
        "üè≥Ô∏è Qual √© a sua nacionalidade?",
        "üíº Fale sobre suas experi√™ncias profissionais.",
        "üåê Quais idiomas voc√™ fala?",
        "üìç Onde voc√™ est√° localizado atualmente?",
        "‚ö†Ô∏è Voc√™ possui multas para pagar? (Sim/N√£o)",
        "üõÇ Possui visto de trabalho v√°lido? (Sim/N√£o)",
        "üöö Est√° dispon√≠vel para mudar de cidade? (Sim/N√£o)",
        "üì∏ Voc√™ √© modelo e deseja enviar fotos? (Sim/N√£o) ‚Äì opcional",
        "üé• Envie um v√≠deo de apresenta√ß√£o (at√© 1 minuto)",
        "üì± Qual o seu Telegram para contato? (adicione @ ou n√∫mero)",
        "üìù Alguma observa√ß√£o adicional?",
    ],
    "es": [
        "üë§ ¬øCu√°l es tu nombre completo?",
        "üéÇ ¬øCu√°ntos a√±os tienes?",
        "üè≥Ô∏è ¬øCu√°l es tu nacionalidad?",
        "üíº Cu√©ntanos sobre tus experiencias profesionales.",
        "üåê ¬øQu√© idiomas hablas?",
        "üìç ¬øD√≥nde te encuentras actualmente?",
        "‚ö†Ô∏è ¬øTienes multas pendientes? (S√≠/No)",
        "üõÇ ¬øTienes visa de trabajo v√°lida? (S√≠/No)",
        "üöö ¬øEst√°s disponible para mudarte? (S√≠/No)",
        "üì∏ ¬øEres modelo y deseas enviar fotos? (S√≠/No) ‚Äì opcional",
        "üé• Env√≠a un video de presentaci√≥n (hasta 1 minuto)",
        "üì± ¬øCu√°l es tu Telegram de contacto? (con @ o n√∫mero)",
        "üìù ¬øAlguna observaci√≥n adicional?",
    ],
    "ru": [
        "üë§ –ö–∞–∫ –≤–∞—Å –∑–æ–≤—É—Ç?",
        "üéÇ –°–∫–æ–ª—å–∫–æ –≤–∞–º –ª–µ—Ç?",
        "üè≥Ô∏è –ö–∞–∫–∞—è —É –≤–∞—Å –Ω–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å?",
        "üíº –†–∞—Å—Å–∫–∞–∂–∏—Ç–µ –æ –≤–∞—à–µ–º –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–º –æ–ø—ã—Ç–µ.",
        "üåê –ö–∞–∫–∏–µ —è–∑—ã–∫–∏ –≤—ã –∑–Ω–∞–µ—Ç–µ?",
        "üìç –ì–¥–µ –≤—ã —Å–µ–π—á–∞—Å –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å?",
        "‚ö†Ô∏è –ï—Å—Ç—å –ª–∏ —É –≤–∞—Å —à—Ç—Ä–∞—Ñ—ã? (–î–∞/–ù–µ—Ç)",
        "üõÇ –ï—Å—Ç—å –ª–∏ —É –≤–∞—Å —Ä–∞–±–æ—á–∞—è –≤–∏–∑–∞? (–î–∞/–ù–µ—Ç)",
        "üöö –ì–æ—Ç–æ–≤—ã –ª–∏ –≤—ã –ø–µ—Ä–µ–µ—Ö–∞—Ç—å? (–î–∞/–ù–µ—Ç)",
        "üì∏ –í—ã –º–æ–¥–µ–ª—å –∏ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ? (–î–∞/–ù–µ—Ç) ‚Äì –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ",
        "üé• –û—Ç–ø—Ä–∞–≤—å—Ç–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–æ–Ω–Ω–æ–µ –≤–∏–¥–µ–æ (–¥–æ 1 –º–∏–Ω)",
        "üì± –í–∞—à Telegram –¥–ª—è —Å–≤—è–∑–∏? (@ –∏–ª–∏ –Ω–æ–º–µ—Ä)",
        "üìù –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∑–∞–º–µ—Ç–∫–∏?",
    ],
}

# r√≥tulos para montar a mensagem final (mantemos PT-like labels conforme exemplo)
FIELDS_LABELS = {
    "pt": [
        "üë§ Nome",
        "üéÇ Idade",
        "üè≥Ô∏è Nacionalidade",
        "üíº Experi√™ncia",
        "üåê Idiomas",
        "üìç Localiza√ß√£o",
        "‚ö†Ô∏è Multas",
        "üõÇ Visto de trabalho v√°lido",
        "üöö Dispon√≠vel para mudar de cidade",
        "üì∏ Modelo (enviou fotos?)",
        "üé• V√≠deo de apresenta√ß√£o",
        "üì± Telegram",
        "üìù Observa√ß√µes",
    ],
    "en": [
        "üë§ Name",
        "üéÇ Age",
        "üè≥Ô∏è Nationality",
        "üíº Experience",
        "üåê Languages",
        "üìç Location",
        "‚ö†Ô∏è Fines",
        "üõÇ Valid work visa",
        "üöö Available to relocate",
        "üì∏ Model (sent photos?)",
        "üé• Presentation video",
        "üì± Telegram",
        "üìù Notes",
    ],
    "es": [
        "üë§ Nombre",
        "üéÇ Edad",
        "üè≥Ô∏è Nacionalidad",
        "üíº Experiencia",
        "üåê Idiomas",
        "üìç Ubicaci√≥n",
        "‚ö†Ô∏è Multas",
        "üõÇ Visa de trabajo v√°lida",
        "üöö Disponible para mudarse",
        "üì∏ Modelo (envi√≥ fotos?)",
        "üé• Video de presentaci√≥n",
        "üì± Telegram",
        "üìù Observaciones",
    ],
    "ru": [
        "üë§ –ò–º—è",
        "üéÇ –í–æ–∑—Ä–∞—Å—Ç",
        "üè≥Ô∏è –ù–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å",
        "üíº –û–ø—ã—Ç",
        "üåê –Ø–∑—ã–∫–∏",
        "üìç –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ",
        "‚ö†Ô∏è –®—Ç—Ä–∞—Ñ—ã",
        "üõÇ –†–∞–±–æ—á–∞—è –≤–∏–∑–∞",
        "üöö –ì–æ—Ç–æ–≤ –∫ –ø–µ—Ä–µ–µ–∑–¥—É",
        "üì∏ –ú–æ–¥–µ–ª—å (—Ñ–æ—Ç–æ?)",
        "üé• –í–∏–¥–µ–æ",
        "üì± Telegram",
        "üìù –ü—Ä–∏–º–µ—á–∞–Ω–∏—è",
    ],
}


# Helper para detectar resposta negativa
def is_negative_answer(text: str) -> bool:
    if not text:
        return False
    t = text.strip().lower()
    return t in {"no", "n", "n√£o", "nao", "–Ω–µ—Ç"}


# ======================
# HANDLERS DO BOT
# ======================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [[InlineKeyboardButton(name, callback_data=code)] for code, name in LANGUAGES.items()]
    await update.message.reply_text(
        "üåê Select your language / Selecione seu idioma / Seleccione su idioma / –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:",
        reply_markup=InlineKeyboardMarkup(keyboard),
    )


async def language_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    lang = query.data
    # init user state
    context.user_data.clear()
    context.user_data["lang"] = lang
    context.user_data["q_index"] = 0
    context.user_data["answers"] = {}   # stores answers by index: "answer_0"...
    context.user_data["photos"] = []    # list of file_ids
    context.user_data["video"] = None   # file_id
    context.user_data["expect_photos"] = False

    # Send security notice and first question
    await query.message.reply_text(SECURITY_MSG[lang])
    await ask_next_question(update, context)


async def ask_next_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    lang = context.user_data.get("lang", "pt")
    idx = context.user_data.get("q_index", 0)
    questions = QUESTIONS[lang]
    if idx >= len(questions):
        # finalize
        await send_to_group(update, context)
        # send thank you to user
        await update.effective_chat.send_message(FINAL_MSG[lang])
        context.user_data.clear()
        return
    # ask current question
    question = questions[idx]
    keyboard = [[InlineKeyboardButton("üîÑ Restart / Reiniciar / –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å", callback_data="restart")]]
    await update.effective_chat.send_message(question, reply_markup=InlineKeyboardMarkup(keyboard))


async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if "q_index" not in context.user_data:
        return
    lang = context.user_data.get("lang", "pt")
    idx = context.user_data["q_index"]
    text = (update.message.text or "").strip()

    # If expecting photos, ignore text and ask to send photos
    if context.user_data.get("expect_photos"):
        await update.message.reply_text({"pt": "üì∏ Por favor envie fotos (m√≠nimo 4).", "en": "üì∏ Please send photos (minimum 4)."}[lang])
        return

    # If current question is the model question (index 9)
    if QUESTIONS[lang][idx].startswith("üì∏"):
        if is_negative_answer(text):
            # store "No" and skip to next
            context.user_data["answers"][f"answer_{idx}"] = "N√£o" if lang == "pt" else "No"
            context.user_data["q_index"] = idx + 1
            await ask_next_question(update, context)
            return
        else:
            # assume yes -> expect photos now
            context.user_data["answers"][f"answer_{idx}"] = "Sim" if lang == "pt" else "Yes"
            context.user_data["expect_photos"] = True
            await update.message.reply_text({"pt": "üì∏ Envie pelo menos 4 fotos agora.", "en": "üì∏ Please send at least 4 photos now."}[lang])
            return

    # Save normal answer
    context.user_data["answers"][f"answer_{idx}"] = text or "-"
    context.user_data["q_index"] = idx + 1
    await ask_next_question(update, context)


async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if "q_index" not in context.user_data:
        return
    lang = context.user_data.get("lang", "pt")
    if not context.user_data.get("expect_photos"):
        await update.message.reply_text({"pt": "üì∑ Para enviar fotos como modelo, responda 'Sim' na pergunta de modelo.", "en": "üì∑ To send photos as a model, answer 'Yes' to the model question."}[lang])
        return
    file_id = update.message.photo[-1].file_id
    context.user_data["photos"].append(file_id)
    count = len(context.user_data["photos"])
    if count < 4:
        await update.message.reply_text({"pt": f"üì∏ {count}/4 recebidas. Envie mais {4 - count}.", "en": f"üì∏ {count}/4 received. Send {4 - count} more."}[lang])
        return
    # enough photos collected
    context.user_data["expect_photos"] = False
    # mark that model question answer stored already; advance
    context.user_data["q_index"] = context.user_data.get("q_index", 0) + 1
    await update.message.reply_text({"pt": "‚úÖ Fotos recebidas. Agora envie seu v√≠deo (se tiver).", "en": "‚úÖ Photos received. Now send your video (if you have one)."}[lang])
    await ask_next_question(update, context)


async def handle_video(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if "q_index" not in context.user_data:
        return
    file_id = None
    if update.message.video:
        file_id = update.message.video.file_id
    elif update.message.document and update.message.document.mime_type and update.message.document.mime_type.startswith("video"):
        file_id = update.message.document.file_id
    if not file_id:
        lang = context.user_data.get("lang", "pt")
        await update.message.reply_text({"pt": "üé• Por favor envie um arquivo de v√≠deo v√°lido.", "en": "üé• Please send a valid video file."}[lang])
        return
    context.user_data["video"] = file_id
    # store a marker in answers for the video question slot if you want
    # advance to next question
    context.user_data["q_index"] = context.user_data.get("q_index", 0) + 1
    await ask_next_question(update, context)


async def callback_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    data = update.callback_query.data
    if data == "restart":
        await handle_restart(update, context)
    elif data in LANGUAGES:
        await language_choice(update, context)
    else:
        await update.callback_query.answer()


async def handle_restart(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    context.user_data.clear()
    await query.edit_message_text("üåê Select your language / Selecione seu idioma:", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton(name, callback_data=code)] for code, name in LANGUAGES.items()]))


# ======================
# ENVIO AGRUPADO (texto + m√≠dia juntos)
# ======================

def build_final_text(data: dict, lang: str) -> str:
    labels = FIELDS_LABELS.get(lang, FIELDS_LABELS["pt"])
    # Build list of values for indices 0..12
    lines = ["üì© Novo candidato via SafeJob!", ""]
    for i, label in enumerate(labels):
        key = f"answer_{i}"
        value = data.get("answers", {}).get(key)
        # for the model and video fields, show yes/no or presence
        if i == 9:
            # model field: if photos exist -> "Sim" else check stored answer
            if data.get("photos"):
                val = "Sim" if lang == "pt" else "Yes"
            else:
                val = data.get("answers", {}).get(key, "N√£o" if lang == "pt" else "No")
            value = val
        elif i == 10:
            # video field: show "Sim" if video present else the stored answer or "-"
            value = "Sim" if data.get("video") else (data.get("answers", {}).get(key, "-"))
        elif value is None:
            value = data.get("answers", {}).get(key, "-")
        lines.append(f"{label}: {value}")
    return "\n".join(lines)


async def send_to_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    data = {
        "answers": context.user_data.get("answers", {}),
        "photos": context.user_data.get("photos", []),
        "video": context.user_data.get("video"),
        "lang": context.user_data.get("lang", "pt"),
    }
    lang = data["lang"]
    final_text = build_final_text(data, lang)

    photos = data.get("photos", [])[:]  # copy
    video_id = data.get("video")

    # Build media list: prefer putting the video as the first media (so caption can be attached to it)
    media_items = []
    if video_id:
        media_items.append(InputMediaVideo(media=video_id, caption=final_text, parse_mode=None))
    # add photos
    for p in photos:
        media_items.append(InputMediaPhoto(media=p))

    try:
        if media_items:
            # Telegram allows up to 10 items per media_group
            # We'll split into chunks of 10. Caption should be on the first media of the first group.
            groups = [media_items[i:i + 10] for i in range(0, len(media_items), 10)]
            # For groups after the first, remove captions (they are already in the first group)
            # If the first group's first item DOES NOT have caption (edge-case), ensure it does.
            # Send each group
            for gi, grp in enumerate(groups):
                # only the first group's first media keeps caption (already set)
                if gi > 0:
                    # remove caption attribute for all items in subsequent groups (if any)
                    for m in grp:
                        try:
                            m.caption = None
                        except Exception:
                            pass
                # send media group
                await context.bot.send_media_group(chat_id=GROUP_ID, media=grp)
        else:
            # no media: simply send message
            await context.bot.send_message(chat_id=GROUP_ID, text=final_text)
    except Exception as e:
        # If media_group fails, fallback to send text then media individually
        try:
            await context.bot.send_message(chat_id=GROUP_ID, text=final_text)
            for p in photos:
                await context.bot.send_photo(chat_id=GROUP_ID, photo=p)
            if video_id:
                await context.bot.send_video(chat_id=GROUP_ID, video=video_id, caption="üé• V√≠deo de apresenta√ß√£o")
        except Exception:
            # give up but log
            print("Failed to send media to group:", e)

# ======================
# BOOT
# ======================

def main():
    app = ApplicationBuilder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(callback_router))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    app.add_handler(MessageHandler(filters.PHOTO, handle_photo))
    # video or mp4 document
    video_filter = filters.VIDEO | filters.Document.MimeType("video/mp4")
    app.add_handler(MessageHandler(video_filter, handle_video))

    print("SafeJob bot running...")
    app.run_polling()


if __name__ == "__main__":
    main()


